window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "mclustering.libfeatures", "modulename": "mclustering.libfeatures", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "mclustering.libfeatures.logger", "modulename": "mclustering.libfeatures", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger mclustering.libfeatures (WARNING)&gt;"}, {"fullname": "mclustering.libfeatures.ResNetFeatures", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures", "kind": "class", "doc": "<p>Extracts deep features from image datasets using torchvision model ResNet50,\nmerges them with metadata, and provides filtering and analysis tools.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nPath to the folder containing image files.</li>\n<li><strong>info_path</strong> (str):\nPath to the metadata text file with observation parameters.</li>\n<li><strong>flag</strong> (str):\nMode of operation: 'read' to load precomputed database, 'extract' to generate it from images.</li>\n<li><strong>device</strong> (str):\nComputation device to use ('cuda' or 'cpu').</li>\n<li><strong>filter_mixed</strong> (bool):\nWhether to filter out mixed-frequency datasets.</li>\n<li><strong>name_pattern</strong> (str):\nRegex pattern to extract dataset names from image filenames.</li>\n<li><strong>extra_params</strong> (dict):\nAdditional parameters for database loading/saving.</li>\n</ul>\n"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.__init__", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">info_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;/mnt/Data/Documents/Projects/pearson-diagram-classification/data/SOLO_info_rswf.txt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">flag</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;read&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;cuda&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">filter_mixed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">name_pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;(solo_L2_rpw-tds-surv-(?:r|t)swf-e_</span><span class=\"se\">\\\\</span><span class=\"s1\">d+</span><span class=\"se\">\\\\</span><span class=\"s1\">w+)&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">extra_params</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.path", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.path", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.info_path", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.info_path", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "&#x27;/mnt/Data/Documents/Projects/pearson-diagram-classification/data/SOLO_info_rswf.txt&#x27;"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.flag", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.flag", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "&#x27;read&#x27;"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.device", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.device", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "&#x27;cuda&#x27;"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.filter_mixed", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.filter_mixed", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.name_pattern", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.name_pattern", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "&#x27;(solo_L2_rpw-tds-surv-(?:r|t)swf-e_\\\\d+\\\\w+)&#x27;"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.extra_params", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.extra_params", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.names", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.names", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.img_path", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.img_path", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.info", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.info", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.database", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.database", "kind": "variable", "doc": "<p></p>\n", "annotation": ": object"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.set_device", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.set_device", "kind": "function", "doc": "<p>Sets the computation device for PyTorch.\nChooses CPU if CUDA is requested but not available.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.model", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.model", "kind": "variable", "doc": "<p>Loads and caches the ResNet50 model and input transformation pipeline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: (model, transform) where model is a torch.nn.Module and transform is a torchvision.transforms.Compose pipeline.</li>\n</ul>\n", "annotation": ": Tuple[torch.nn.modules.module.Module, torchvision.transforms.transforms.Compose]"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.find_mixed_freq", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.find_mixed_freq", "kind": "function", "doc": "<p>Identifies dataset names with mixed sampling frequencies in the metadata.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.Series</strong>: Series of dataset names to exclude.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.filtering_imgs", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.filtering_imgs", "kind": "function", "doc": "<p>Filters out image paths (in self.img_path,self.names) corresponding to mixed-frequency datasets.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nDirectory containing images.</li>\n<li><strong>name_pattern</strong> (str):\nRegular expression to extract dataset names from filenames.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">name_pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.features", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.features", "kind": "function", "doc": "<p>Extracts deep features from all images using the ResNet50 model.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>numpy.ndarray</strong>: Array of feature vectors for all valid images.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.features_to_db", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.features_to_db", "kind": "function", "doc": "<p>Converts extracted features to a pandas DataFrame and adds metadata columns.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame</strong>: DataFrame containing features and metadata columns.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.create_database", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.create_database", "kind": "function", "doc": "<p>Extracts features, merges them with metadata, and constructs a full DataFrame.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame</strong>: Feature database with metadata.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.filtering_nonzerocolumns", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.filtering_nonzerocolumns", "kind": "function", "doc": "<p>Removes columns in the feature matrix that contain only zeros.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame</strong>: Filtered DataFrame with non-zero feature columns.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.filtering_by_variance", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.filtering_by_variance", "kind": "function", "doc": "<p>Removes low-variance features from the database.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>threshold</strong> (float):\nMinimum variance required for a feature to be retained.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame</strong>: Filtered DataFrame with high-variance features.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">5e-05</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.info_on_features", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.info_on_features", "kind": "function", "doc": "<p>Prints statistics on extracted features and optionally visualizes variance distribution.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame, optional):\nDataFrame to analyze. If None, uses self.database.</li>\n<li><strong>visualize</strong> (bool):\nIf True, show a histogram of feature variances.</li>\n<li><strong>title</strong> (str):\nOptional title for the plot.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">visualize</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libfeatures.ResNetFeatures.visualize_variance", "modulename": "mclustering.libfeatures", "qualname": "ResNetFeatures.visualize_variance", "kind": "function", "doc": "<p>Visualizes the distribution of feature variances as a histogram.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>variances</strong> (numpy.ndarray):\nArray of variances for each feature.</li>\n<li><strong>title</strong> (str):\nOptional plot title.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">variances</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libpreprocessing", "modulename": "mclustering.libpreprocessing", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "mclustering.libpreprocessing.logger", "modulename": "mclustering.libpreprocessing", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger mclustering.libpreprocessing (WARNING)&gt;"}, {"fullname": "mclustering.libpreprocessing.FeaturesPreprocessing", "modulename": "mclustering.libpreprocessing", "qualname": "FeaturesPreprocessing", "kind": "class", "doc": "<p>Applies dimensionality reduction and scaling pipelines to a DataFrame of features.</p>\n\n<p>This class provides a flexible wrapper around common preprocessing techniques \nsuch as PCA, StandardScaler, Normalizer, and UMAP. The sequence of transformations is defined \nby a string-based pipeline syntax.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nStored copy or reference to the input DataFrame.</li>\n<li><strong>model_registry</strong> (dict):\nDictionary mapping method names to their corresponding sklearn/UMAP classes.</li>\n<li><strong>default_params</strong> (dict):\nDefault parameters for supported transformation models.</li>\n</ul>\n"}, {"fullname": "mclustering.libpreprocessing.FeaturesPreprocessing.__init__", "modulename": "mclustering.libpreprocessing", "qualname": "FeaturesPreprocessing.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">copy</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "mclustering.libpreprocessing.FeaturesPreprocessing.df", "modulename": "mclustering.libpreprocessing", "qualname": "FeaturesPreprocessing.df", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "mclustering.libpreprocessing.FeaturesPreprocessing.model_registry", "modulename": "mclustering.libpreprocessing", "qualname": "FeaturesPreprocessing.model_registry", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "mclustering.libpreprocessing.FeaturesPreprocessing.default_params", "modulename": "mclustering.libpreprocessing", "qualname": "FeaturesPreprocessing.default_params", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "mclustering.libpreprocessing.FeaturesPreprocessing.build_pipeline", "modulename": "mclustering.libpreprocessing", "qualname": "FeaturesPreprocessing.build_pipeline", "kind": "function", "doc": "<p>Builds a preprocessing pipeline from a string specification.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>pipe_str</strong> (str):\nPipeline string, e.g., 'scaler+pca+umap2d'.</li>\n<li><strong>params</strong> (dict, optional):\nDictionary mapping pipeline step names to parameter dicts.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>sklearn.pipeline.Pipeline</strong>: The constructed pipeline.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If pipeline step name is not found in defaults.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">pipe_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sklearn</span><span class=\"o\">.</span><span class=\"n\">pipeline</span><span class=\"o\">.</span><span class=\"n\">Pipeline</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libpreprocessing.FeaturesPreprocessing.preprocessing", "modulename": "mclustering.libpreprocessing", "qualname": "FeaturesPreprocessing.preprocessing", "kind": "function", "doc": "<p>Applies a sequence of preprocessing transformations to the feature data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nFeature matrix (excluding metadata).</li>\n<li><strong>pipe_str</strong> (str):\nA string representing the sequence of transformations to apply,\njoined by '+'. For example: 'pca+umap2d'.</li>\n<li><strong>params</strong> (dict, optional):\nCustom parameters for the transformations.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>numpy.ndarray or None</strong>: Transformed feature array if input is non-empty; otherwise None.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If unknown transformation names are specified.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">pipe_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libpreprocessing.FeaturesPreprocessing.wrapper_preprop", "modulename": "mclustering.libpreprocessing", "qualname": "FeaturesPreprocessing.wrapper_preprop", "kind": "function", "doc": "<p>Applies preprocessing to the feature part of a DataFrame while preserving metadata.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nFull input DataFrame including metadata and features.</li>\n<li><strong>pipe_str</strong> (str):\nPipeline string specifying preprocessing steps (e.g., 'scaler+pca+umap2d').</li>\n<li><strong>params</strong> (dict, optional):\nCustom parameters for the transformations.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame</strong>: New DataFrame containing preserved metadata and transformed features.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If feature transformation fails or input DataFrame is empty.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">pipe_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering", "modulename": "mclustering.libclustering", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "mclustering.libclustering.logger", "modulename": "mclustering.libclustering", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger mclustering.libclustering (WARNING)&gt;"}, {"fullname": "mclustering.libclustering.Clustering", "modulename": "mclustering.libclustering", "qualname": "Clustering", "kind": "class", "doc": "<p>Performs clustering on a feature dataset and manages file sorting and visualization.</p>\n\n<p>This class supports unsupervised clustering using the HDBSCAN algorithm,\nupdates the associated feature database with labels, and organizes files\ninto directories based on cluster assignments. It also includes tools for\ncluster visualization using PCA and UMAP.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nInput feature DataFrame containing at least 'oldpath' and feature columns.</li>\n<li><strong>copy</strong> (bool, optional):\nIf True, the input DataFrame is copied internally. Default is False.</li>\n<li><strong>clear</strong> (bool, optional):\nIf True, the target directory './processed' will be cleared before use. Default is True.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nThe working DataFrame, either copied or referenced.</li>\n<li><strong>num_clusters</strong> (int):\nNumber of clusters found (excluding noise).</li>\n<li><strong>labels</strong> (list of int):\nCluster labels assigned by HDBSCAN (-1 indicates noise).</li>\n<li><strong>dir</strong> (str):\nDirectory path where clustered files will be organized (default is './processed').</li>\n</ul>\n"}, {"fullname": "mclustering.libclustering.Clustering.__init__", "modulename": "mclustering.libclustering", "qualname": "Clustering.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">results_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">copy</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">clear</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "mclustering.libclustering.Clustering.cluster_algorithms", "modulename": "mclustering.libclustering", "qualname": "Clustering.cluster_algorithms", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "mclustering.libclustering.Clustering.default_params", "modulename": "mclustering.libclustering", "qualname": "Clustering.default_params", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "mclustering.libclustering.Clustering.num_clusters", "modulename": "mclustering.libclustering", "qualname": "Clustering.num_clusters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "mclustering.libclustering.Clustering.labels", "modulename": "mclustering.libclustering", "qualname": "Clustering.labels", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "mclustering.libclustering.Clustering.dir", "modulename": "mclustering.libclustering", "qualname": "Clustering.dir", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "mclustering.libclustering.Clustering.setup_clustering", "modulename": "mclustering.libclustering", "qualname": "Clustering.setup_clustering", "kind": "function", "doc": "<p>Sets up the clustering model using default or custom parameters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (str):\nName of the clustering algorithm.</li>\n<li><strong>params</strong> (dict, optional):\nCustom parameters for the clustering algorithm.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: (model_type, model_instance)</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the model configuration is not found.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">object</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.do_clustering", "modulename": "mclustering.libclustering", "qualname": "Clustering.do_clustering", "kind": "function", "doc": "<p>Applies clustering to the given feature matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame or numpy.ndarray):\nFeature matrix.</li>\n<li><strong>model_type</strong> (str):\nName of the clustering algorithm.</li>\n<li><strong>params</strong> (dict, optional):\nParameters for the clustering algorithm.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: (labels, number_of_clusters)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">model_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.update_database", "modulename": "mclustering.libclustering", "qualname": "Clustering.update_database", "kind": "function", "doc": "<p>Inserts the cluster labels into the internal DataFrame as a new column 'label'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.create_dirs", "modulename": "mclustering.libclustering", "qualname": "Clustering.create_dirs", "kind": "function", "doc": "<p>Creates output directories for each cluster and a separate one for noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>clear</strong> (bool):\nWhether to clear the directory before creation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">clear</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.create_newpath", "modulename": "mclustering.libclustering", "qualname": "Clustering.create_newpath", "kind": "function", "doc": "<p>Assigns new output paths for each sample in the DataFrame based on their cluster label.\nClustered samples go to './processed/label_<cluster>', noise samples go to './processed/noise'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.copy_files", "modulename": "mclustering.libclustering", "qualname": "Clustering.copy_files", "kind": "function", "doc": "<p>Copies image files from their original locations ('oldpath') to the new cluster-assigned directories ('path').</p>\n\n<p>Skips rows where either path is missing or not a string. Errors are printed but do not interrupt execution.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.organize_files_by_cluster", "modulename": "mclustering.libclustering", "qualname": "Clustering.organize_files_by_cluster", "kind": "function", "doc": "<p>Organizes image files into directories by cluster.</p>\n\n<p>This method:</p>\n\n<ul>\n<li>Creates cluster directories</li>\n<li>Assigns new file paths</li>\n<li>Copies files to new locations</li>\n<li>Removes the 'oldpath' column from the DataFrame</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame</strong>: resulted database self.df</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.visualize", "modulename": "mclustering.libclustering", "qualname": "Clustering.visualize", "kind": "function", "doc": "<p>Reduces the feature space to 2D using a preprocessing pipeline,\napplies clustering, and plots the results.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nInput DataFrame containing features.</li>\n<li><strong>model_cluster</strong> (str):\nClustering algorithm to use.</li>\n<li><strong>model_preprop</strong> (str):\nPreprocessing pipeline string (e.g., 'PCA+UMAP2D').</li>\n<li><strong>params</strong> (dict, optional):\nDictionary of parameters for the clustering algorithm.</li>\n<li><strong>filename</strong> (str, optional):\nOutput filename (without extension) for saving the plot.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">model_cluster</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;HDBSCAN&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">model_preprop</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;PCA+UMAP2D&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.visdata_preparation", "modulename": "mclustering.libclustering", "qualname": "Clustering.visdata_preparation", "kind": "function", "doc": "<p>Prepares data for visualization: preprocesses features and applies clustering.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nInput DataFrame.</li>\n<li><strong>model_cluster</strong> (str):\nClustering algorithm.</li>\n<li><strong>model_preprop</strong> (str):\nPreprocessing pipeline.</li>\n<li><strong>params</strong> (dict, optional):\nClustering parameters.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: (2D_features, labels, number_of_clusters)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">model_cluster</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;HDBSCAN&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">model_preprop</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;PCA+UMAP2D&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.saving_figs", "modulename": "mclustering.libclustering", "qualname": "Clustering.saving_figs", "kind": "function", "doc": "<p>Saves the clustering plot in PDF and PNG formats.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>filename</strong> (str):\nBase filename to use for saving.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.scores", "modulename": "mclustering.libclustering", "qualname": "Clustering.scores", "kind": "function", "doc": "<p>Computes and prints clustering evaluation scores.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nFull DataFrame including features.</li>\n<li><strong>labels</strong> (numpy.ndarray):\nCluster labels for each sample.</li>\n</ul>\n\n<h6 id=\"prints\">Prints</h6>\n\n<p>Silhouette Score and Davies-Bouldin Index.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">labels</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libclustering.Clustering.stability_score", "modulename": "mclustering.libclustering", "qualname": "Clustering.stability_score", "kind": "function", "doc": "<p>Computes and prints Adjusted Rand Index for labels of two clustering methods.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>methods1, methods2</strong> (str):\nNames of used clustering methods</li>\n<li><strong>labels1, labels2</strong> (np.array):\nArrays with corresponding labels of clusters</li>\n</ul>\n\n<h6 id=\"prints\">Prints</h6>\n\n<p>Adjusted Rand Index</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">method1</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">labels1</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">method2</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">labels2</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice", "modulename": "mclustering.libservice", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "mclustering.libservice.logger", "modulename": "mclustering.libservice", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger mclustering.libservice (WARNING)&gt;"}, {"fullname": "mclustering.libservice.ServiceFuncs", "modulename": "mclustering.libservice", "qualname": "ServiceFuncs", "kind": "class", "doc": "<p>A static utility class providing helper functions for file handling, \nimage validation, and folder management.</p>\n\n<p>This class is not meant to be instantiated.</p>\n"}, {"fullname": "mclustering.libservice.ServiceFuncs.init_error", "modulename": "mclustering.libservice", "qualname": "ServiceFuncs.init_error", "kind": "function", "doc": "<p>Raise an error to prevent instantiation of static utility classes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.ServiceFuncs.check_extension", "modulename": "mclustering.libservice", "qualname": "ServiceFuncs.check_extension", "kind": "function", "doc": "<p>Check if a file has one of the allowed extensions.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_path</strong> (str):\nPath to the file.</li>\n<li><strong>allowed_extensions</strong> (tuple of str, optional):\nTuple of allowed file extensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if the file has an allowed extension, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">allowed_extensions</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;.jpg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.jpeg&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.png&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.bmp&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.tiff&#39;</span><span class=\"p\">)</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.ServiceFuncs.extract_observ_data", "modulename": "mclustering.libservice", "qualname": "ServiceFuncs.extract_observ_data", "kind": "function", "doc": "<p>Extract observation type and date from the filename using regex.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nFile path or name.</li>\n<li><strong>pattern</strong> (str):\nRegular expression pattern to extract observation type and date.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: (observation_type, datetime.date)</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the pattern is not found.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;((?:r|t))swf-e_(</span><span class=\"se\">\\\\</span><span class=\"s1\">d</span><span class=\"si\">{4}</span><span class=\"s1\">)(</span><span class=\"se\">\\\\</span><span class=\"s1\">d</span><span class=\"si\">{2}</span><span class=\"s1\">)(</span><span class=\"se\">\\\\</span><span class=\"s1\">d</span><span class=\"si\">{2}</span><span class=\"s1\">)&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.ServiceFuncs.preparing_folder", "modulename": "mclustering.libservice", "qualname": "ServiceFuncs.preparing_folder", "kind": "function", "doc": "<p>Prepare a directory for output, optionally clearing its contents.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dir_name</strong> (str):\nPath to the target directory.</li>\n<li><strong>clear</strong> (bool):\nIf True, the directory will be deleted and recreated.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>Exception</strong>: If directory manipulation fails.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dir_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">clear</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.ServiceFuncs.input_name", "modulename": "mclustering.libservice", "qualname": "ServiceFuncs.input_name", "kind": "function", "doc": "<p>Extract an identifier from a file path using a regular expression.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_path</strong> (str):\nFile path or name.</li>\n<li><strong>pattern</strong> (str):\nRegular expression to extract the identifier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Extracted identifier or the original input if no match found.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">input_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;images_(</span><span class=\"se\">\\\\</span><span class=\"s1\">w+)&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.ServiceFuncs.create_name", "modulename": "mclustering.libservice", "qualname": "ServiceFuncs.create_name", "kind": "function", "doc": "<p>Constructs a filename by combining a base name with a suffix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>default_filename</strong> (str):\nBase filename.</li>\n<li><strong>file_to_write</strong> (str, optional):\nCustom filename provided by the user.</li>\n<li><strong>suffix</strong> (str, optional):\nSuffix to append to the filename.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Full filename with optional suffix.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">file_to_write</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.DBFuncs", "modulename": "mclustering.libservice", "qualname": "DBFuncs", "kind": "class", "doc": "<p>A static utility class providing helper functions for database management,\nincluding loading, saving, and processing metadata.</p>\n\n<p>This class is not meant to be instantiated.</p>\n"}, {"fullname": "mclustering.libservice.DBFuncs.load_info", "modulename": "mclustering.libservice", "qualname": "DBFuncs.load_info", "kind": "function", "doc": "<p>Load and preprocess metadata from a space-delimited text file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>info_path</strong> (str):\nPath to the metadata file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame</strong>: Parsed and enriched metadata, including date and sampling rate in kHz.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">info_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.DBFuncs.save_database", "modulename": "mclustering.libservice", "qualname": "DBFuncs.save_database", "kind": "function", "doc": "<p>Save a pandas DataFrame to disk.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nData to save.</li>\n<li><strong>file_to_write</strong> (str, optional):\nBase filename without extension.</li>\n<li><strong>kind</strong> ({'pickle', 'json'}):\nFormat to save the file in.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">file_to_write</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kind</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;pickle&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.DBFuncs.read_database", "modulename": "mclustering.libservice", "qualname": "DBFuncs.read_database", "kind": "function", "doc": "<p>Read a pandas DataFrame from a file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_to_read</strong> (str, optional):\nBase filename without extension.</li>\n<li><strong>kind</strong> ({'pickle', 'json'}):\nFormat of the file.</li>\n<li><strong>dtype</strong> (dict, optional):\nColumn types to enforce when reading JSON.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame or None</strong>: The loaded DataFrame, or None if reading failed.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_to_read</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kind</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;pickle&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;obsertype&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;category&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;label&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;category&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;date&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;datetime&#39;</span><span class=\"p\">}</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.DBFuncs.split_into_two", "modulename": "mclustering.libservice", "qualname": "DBFuncs.split_into_two", "kind": "function", "doc": "<p>Split a DataFrame into features and metadata columns.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nInput DataFrame.</li>\n<li><strong>excluded_columns</strong> (list of str, optional):\nColumns to exclude from the features set.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple of pandas.DataFrame</strong>: (df_features, df_metadata)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">excluded_columns</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">,</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.Logg", "modulename": "mclustering.libservice", "qualname": "Logg", "kind": "class", "doc": "<p>A utility class for managing logging setup and log file naming.</p>\n\n<p>This class is not meant to be instantiated.</p>\n"}, {"fullname": "mclustering.libservice.Logg.get_log_filename", "modulename": "mclustering.libservice", "qualname": "Logg.get_log_filename", "kind": "function", "doc": "<p>Determines a log file name.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_dir</strong> (str):\nDirectory where log files are stored.</li>\n<li><strong>log_name</strong> (str or None):\nCustom log file name. If None, a new sequential name will be generated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Full path to the log file.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">log_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;logs&#39;</span>, </span><span class=\"param\"><span class=\"n\">log_name</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "mclustering.libservice.Logg.setup_logging", "modulename": "mclustering.libservice", "qualname": "Logg.setup_logging", "kind": "function", "doc": "<p>Set up logging configuration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_file</strong> (str):\nPath to the log file.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">log_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;pipeline.log&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive", "modulename": "minteractive.libinteractive", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "minteractive.libinteractive.logger", "modulename": "minteractive.libinteractive", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger minteractive.libinteractive (WARNING)&gt;"}, {"fullname": "minteractive.libinteractive.InputManager", "modulename": "minteractive.libinteractive", "qualname": "InputManager", "kind": "class", "doc": "<p>A static utility class for handling interactive user input in the console.</p>\n\n<p>Provides methods for:</p>\n\n<ul>\n<li>Displaying welcome messages and prompts</li>\n<li>Asking yes/no questions with validation</li>\n<li>Parsing dictionaries from key=value input</li>\n<li>Converting string input to appropriate Python types (bool, int, float, str)</li>\n<li>Confirming or modifying regular expressions for dataset matching</li>\n</ul>\n\n<p>This class is not meant to be instantiated.</p>\n"}, {"fullname": "minteractive.libinteractive.InputManager.input_wrapper", "modulename": "minteractive.libinteractive", "qualname": "InputManager.input_wrapper", "kind": "function", "doc": "<p>Prompts the user for input and handles KeyboardInterrupt gracefully.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>message</strong> (str):\nPrompt message to display to the user.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str or None</strong>: User input string or None if interrupted.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.InputManager.welcome_message", "modulename": "minteractive.libinteractive", "qualname": "InputManager.welcome_message", "kind": "function", "doc": "<p>Prints a welcome message with initial instructions for placing image data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.InputManager.get_bool", "modulename": "minteractive.libinteractive", "qualname": "InputManager.get_bool", "kind": "function", "doc": "<p>Prompts the user for a True/False response.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>prompt</strong> (str):\nPrompt text for user input.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: Boolean interpretation of the user's input.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>KeyError</strong>: If input is not 'true' or 'false' (case-insensitive).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">prompt</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.InputManager.filter_mixed_freq", "modulename": "minteractive.libinteractive", "qualname": "InputManager.filter_mixed_freq", "kind": "function", "doc": "<p>Asks the user whether to filter out mixed-frequency data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name_pattern</strong> (str):\nDefault regular expression used to match dataset names.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>filter_mixed</strong> (bool):\nWhether to apply frequency filtering.</li>\n<li><strong>name_pattern</strong> (str):\nPossibly updated regex pattern provided by the user.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name_pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.InputManager.input_dict", "modulename": "minteractive.libinteractive", "qualname": "InputManager.input_dict", "kind": "function", "doc": "<p>Interactively builds a dictionary from user input of key=value pairs.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>prompt</strong> (str):\nMessage shown before input begins.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict</strong>: Dictionary parsed from input.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">prompt</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Enter pairs of key=value (empty string - end): &#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.InputManager.parse_value", "modulename": "minteractive.libinteractive", "qualname": "InputManager.parse_value", "kind": "function", "doc": "<p>Attempts to convert a string to a boolean, integer, float, or returns as string.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong> (str):\nInput string to parse.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>object</strong>: Parsed value (bool, int, float, or str).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">object</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.InputManager.check_if_database", "modulename": "minteractive.libinteractive", "qualname": "InputManager.check_if_database", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.PathManager", "modulename": "minteractive.libinteractive", "qualname": "PathManager", "kind": "class", "doc": "<p>A static utility class for managing file paths, folders, and output saving.</p>\n\n<p>Provides methods for:</p>\n\n<ul>\n<li>Prompting and validating image folder names</li>\n<li>Creating result and base directories</li>\n<li>Asking for custom or default paths</li>\n<li>Saving pandas DataFrames with user-defined filenames</li>\n</ul>\n\n<p>This class is not meant to be instantiated.</p>\n"}, {"fullname": "minteractive.libinteractive.PathManager.preparations", "modulename": "minteractive.libinteractive", "qualname": "PathManager.preparations", "kind": "function", "doc": "<p>Sets up required working directories and obtains the user's image folder name.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>input_imags</strong> (str):\nName of the subdirectory in 'images/' containing image data.</li>\n<li><strong>default_filename</strong> (str):\nBase filename used for saving feature-related data.</li>\n<li><strong>results_dir</strong> (str):\nDirectory for processed results.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.PathManager.create_base_dirs", "modulename": "minteractive.libinteractive", "qualname": "PathManager.create_base_dirs", "kind": "function", "doc": "<p>Ensures that a set of base directories exists (creates if missing).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>*args</strong> (str):\nNames of directories to ensure exist within the current working directory.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.PathManager.images_folder", "modulename": "minteractive.libinteractive", "qualname": "PathManager.images_folder", "kind": "function", "doc": "<p>Prompts the user to input a valid subdirectory name inside 'images/'.</p>\n\n<p>Repeats until a valid directory is given.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Valid image folder name.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.PathManager.create_results_dir", "modulename": "minteractive.libinteractive", "qualname": "PathManager.create_results_dir", "kind": "function", "doc": "<p>Constructs paths for results and prompts whether to clear previous outputs.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_imags</strong> (str):\nImage folder name, used to derive output paths.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>default_filename</strong> (str):\nBase path for saving output data.</li>\n<li><strong>results_dir</strong> (str):\nDirectory for saving processed files.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">input_imags</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.PathManager.get_path", "modulename": "minteractive.libinteractive", "qualname": "PathManager.get_path", "kind": "function", "doc": "<p>Prompts the user for a path or returns the default if input is empty.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>message</strong> (str):\nPrompt to display.</li>\n<li><strong>default_path</strong> (str):\nPath to use if user provides nothing.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: The path chosen by the user.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">default_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libinteractive.PathManager.saving_database", "modulename": "minteractive.libinteractive", "qualname": "PathManager.saving_database", "kind": "function", "doc": "<p>Prompts the user to save the DataFrame to a file with optional suffix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>df</strong> (pandas.DataFrame):\nData to be saved.</li>\n<li><strong>default_filename</strong> (str):\nDefault file base name.</li>\n<li><strong>message</strong> (str):\nPrompt shown to the user.</li>\n<li><strong>suf</strong> (str):\nDefault suffix to append to the filename.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">suf</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline", "modulename": "minteractive.libprocesspipeline", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "minteractive.libprocesspipeline.logger", "modulename": "minteractive.libprocesspipeline", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger minteractive.libprocesspipeline (WARNING)&gt;"}, {"fullname": "minteractive.libprocesspipeline.FeatureManager", "modulename": "minteractive.libprocesspipeline", "qualname": "FeatureManager", "kind": "class", "doc": "<p>This class serves as a high-level command-line wrapper around the functionality of <code>libfeatures</code>.\nIt rules the process of features extraction from images or loading from a file.</p>\n\n<p>This class is not intended to be instantiated.</p>\n"}, {"fullname": "minteractive.libprocesspipeline.FeatureManager.get_features", "modulename": "minteractive.libprocesspipeline", "qualname": "FeatureManager.get_features", "kind": "function", "doc": "<p>Asks the user whether to extract new features or read from file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_imags</strong> (str):\nSubdirectory name with image data.</li>\n<li><strong>info_path</strong> (str):\nPath to the metadata file.</li>\n<li><strong>default_filename</strong> (str):\nDefault base filename for feature data.</li>\n<li><strong>name_pattern</strong> (str):\nRegex pattern for identifying dataset names.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ResNetFeatures</strong>: An instance of the ResNetFeatures class containing the loaded/extracted features.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_imags</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">info_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">name_pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.FeatureManager.extract_features", "modulename": "minteractive.libprocesspipeline", "qualname": "FeatureManager.extract_features", "kind": "function", "doc": "<p>Initializes feature extraction and saves them to file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_imags</strong> (str):\nFolder containing images.</li>\n<li><strong>info_path</strong> (str):\nPath to the metadata file.</li>\n<li><strong>default_filename</strong> (str):\nDefault file path for saving results.</li>\n<li><strong>name_pattern</strong> (str):\nRegex pattern for dataset name recognition.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ResNetFeatures</strong>: Object containing the extracted feature database.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_imags</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">info_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">name_pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.FeatureManager.read_features", "modulename": "minteractive.libprocesspipeline", "qualname": "FeatureManager.read_features", "kind": "function", "doc": "<p>Loads previously saved feature data from a file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_imags</strong> (str):\nFolder containing images.</li>\n<li><strong>info_path</strong> (str):\nPath to the metadata file.</li>\n<li><strong>default_filename</strong> (str):\nDefault file path for loading.</li>\n<li><strong>name_pattern</strong> (str):\nRegex pattern for dataset name recognition.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ResNetFeatures</strong>: Object containing the loaded feature database.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_imags</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">info_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">name_pattern</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.ProcessingSteps", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingSteps", "kind": "class", "doc": "<p>Provides static methods for data processing steps, including filtering,\npreprocessing (dimensionality reduction), clustering, and result evaluation.</p>\n\n<p>This class is not intended to be instantiated.</p>\n"}, {"fullname": "minteractive.libprocesspipeline.ProcessingSteps.filtration", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingSteps.filtration", "kind": "function", "doc": "<p>Applies variance-based filtering to the feature set.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (ResNetFeatures):\nInput feature database.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ResNetFeatures</strong>: Filtered features with updated <code>.database</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span></span><span class=\"return-annotation\">) -> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.ProcessingSteps.run_preprocessing", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingSteps.run_preprocessing", "kind": "function", "doc": "<p>Applies a sequence of dimensionality reduction steps to the feature matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (ResNetFeatures):\nThe extracted and optionally filtered features.</li>\n<li><strong>pipe_str</strong> (str, optional):\nPipeline specification string, e.g., 'PCA+UMAPND'.</li>\n<li><strong>params</strong> (dict, optional):\nOptional parameters for preprocessing steps.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame</strong>: Transformed feature DataFrame with original metadata preserved.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">pipe_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;PCA+UMAPND&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.ProcessingSteps.run_clustering", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingSteps.run_clustering", "kind": "function", "doc": "<p>Performs clustering and sorts image files into corresponding folders.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (pandas.DataFrame):\nThe feature matrix with metadata.</li>\n<li><strong>results_dir</strong> (str):\nPath to output directory.</li>\n<li><strong>model_type</strong> (str, optional):\nClustering model identifier.</li>\n<li><strong>params</strong> (dict, optional):\nModel parameters.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Clustering</strong>: Clustering object with updated label assignments and organized folders.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">results_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">model_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hdbscan&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">params</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libclustering</span><span class=\"o\">.</span><span class=\"n\">Clustering</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.ProcessingSteps.evaluation_clustering_results", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingSteps.evaluation_clustering_results", "kind": "function", "doc": "<p>Display clustering quality scores and perform visualization.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>clusters</strong> (Clustering):\nClustered object to evaluate.</li>\n<li><strong>source_features</strong> (ResNetFeatures):\nOriginal features to visaulize.</li>\n<li><strong>model_type</strong> (str):\nClustering model identifier.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">clusters</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libclustering</span><span class=\"o\">.</span><span class=\"n\">Clustering</span>,</span><span class=\"param\">\t<span class=\"n\">source_features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">model_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.ProcessingSteps.evaluation_preprocessing_results", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingSteps.evaluation_preprocessing_results", "kind": "function", "doc": "<p>Show histogram of feature variances and preprocessing info.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>processed_database</strong> (pd.DataFrame):\nPreprocessed feature data.</li>\n<li><strong>pipeline</strong> (str):\nPipeline descriptor used.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">processed_database</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">pipeline</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.ProcessingPipeline", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingPipeline", "kind": "class", "doc": "<p>Orchestrates the full or step-wise processing of feature data.</p>\n\n<p>This class is not intended to be instantiated.</p>\n"}, {"fullname": "minteractive.libprocesspipeline.ProcessingPipeline.run_processing", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingPipeline.run_processing", "kind": "function", "doc": "<p>Offers the user a choice between standard pipeline execution or custom steps.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (ResNetFeatures):\nFeature database.</li>\n<li><strong>default_filename</strong> (str):\nBase name for saving intermediate or final results.</li>\n<li><strong>results_dir</strong> (str):\nDirectory for result outputs.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">results_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.ProcessingPipeline.standard_algorithm", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingPipeline.standard_algorithm", "kind": "function", "doc": "<p>Executes the full default processing pipeline:</p>\n\n<ol>\n<li>Feature filtering by variance</li>\n<li>Dimensionality reduction with PCA and UMAP</li>\n<li>Clustering with HDBSCAN</li>\n<li>Visualization</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (ResNetFeatures):\nInput feature database object.</li>\n<li><strong>default_filename</strong> (str):\nBase filename for saving outputs.</li>\n<li><strong>results_dir</strong> (str):\nOutput directory.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">results_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.ProcessingPipeline.choose_block", "modulename": "minteractive.libprocesspipeline", "qualname": "ProcessingPipeline.choose_block", "kind": "function", "doc": "<p>Provides UI to manually select individual processing steps.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (ResNetFeatures):\nFeature data.</li>\n<li><strong>default_filename</strong> (str):\nOutput file base name.</li>\n<li><strong>results_dir</strong> (str):\nDirectory for results.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">results_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.PipelineUI", "modulename": "minteractive.libprocesspipeline", "qualname": "PipelineUI", "kind": "class", "doc": "<p>Provides user interface utilities for preprocessing and clustering configuration and result handling.</p>\n"}, {"fullname": "minteractive.libprocesspipeline.PipelineUI.source_data", "modulename": "minteractive.libprocesspipeline", "qualname": "PipelineUI.source_data", "kind": "function", "doc": "<p>Chooses whether to use previous step data or load from file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>processed</strong> (pd.DataFrame or None):\nData from previous pipeline step.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pd.DataFrame or None</strong>: Selected feature data.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">processed</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.PipelineUI.get_processing_params", "modulename": "minteractive.libprocesspipeline", "qualname": "PipelineUI.get_processing_params", "kind": "function", "doc": "<p>Prompts user to input parameters for each step in a pipeline.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>pipeline</strong> (str):\nPipeline string.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict</strong>: Stepwise parameter dictionary.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pipeline</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.PipelineUI.get_clustering_params", "modulename": "minteractive.libprocesspipeline", "qualname": "PipelineUI.get_clustering_params", "kind": "function", "doc": "<p>Prompts user for clustering parameters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (str):\nModel name.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict</strong>: Clustering parameters.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.PipelineUI.clustering_setup", "modulename": "minteractive.libprocesspipeline", "qualname": "PipelineUI.clustering_setup", "kind": "function", "doc": "<p>Guides user through clustering setup and runs clustering.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (ResNetFeatures):\nOriginal features.</li>\n<li><strong>data</strong> (pd.DataFrame):\nProcessed feature matrix.</li>\n<li><strong>default_filename</strong> (str):\nOutput file base name.</li>\n<li><strong>results_dir</strong> (str):\nDirectory for result output.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">results_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.PipelineUI.preprocessing_setup", "modulename": "minteractive.libprocesspipeline", "qualname": "PipelineUI.preprocessing_setup", "kind": "function", "doc": "<p>Guides user through pipeline setup and runs preprocessing.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (ResNetFeatures):\nOriginal feature data.</li>\n<li><strong>default_filename</strong> (str):\nFile name base for saving.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pd.DataFrame</strong>: Processed feature data.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.PipelineUI.to_deal_with_results_features", "modulename": "minteractive.libprocesspipeline", "qualname": "PipelineUI.to_deal_with_results_features", "kind": "function", "doc": "<p>Provides user options for processed feature output: save, visualize.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>pipeline</strong> (str):\nPipeline string.</li>\n<li><strong>processed</strong> (pd.DataFrame):\nResulting data.</li>\n<li><strong>default_filename</strong> (str):\nOutput file base.</li>\n<li><strong>suf</strong> (str):\nSuffix to append to filename.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pipeline</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">processed</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">suf</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "minteractive.libprocesspipeline.PipelineUI.to_deal_with_results_clustering", "modulename": "minteractive.libprocesspipeline", "qualname": "PipelineUI.to_deal_with_results_clustering", "kind": "function", "doc": "<p>Provides user options for clustering result output.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>clusters</strong> (Clustering):\nResulting clustering.</li>\n<li><strong>source_features</strong> (ResNetFeatures):\nOriginal features.</li>\n<li><strong>model_type</strong> (str):\nModel used.</li>\n<li><strong>default_filename</strong> (str):\nOutput base name.</li>\n<li><strong>suf</strong> (str):\nSuffix for filename.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">clusters</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libclustering</span><span class=\"o\">.</span><span class=\"n\">Clustering</span>,</span><span class=\"param\">\t<span class=\"n\">source_features</span><span class=\"p\">:</span> <span class=\"n\">mclustering</span><span class=\"o\">.</span><span class=\"n\">libfeatures</span><span class=\"o\">.</span><span class=\"n\">ResNetFeatures</span>,</span><span class=\"param\">\t<span class=\"n\">model_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">suf</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs", "modulename": "manalyse.plot_funcs", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter", "modulename": "manalyse.plot_funcs", "qualname": "Plotter", "kind": "class", "doc": "<p>Visualization of SoLo measurements.\nReads data from a .pkl or .json database, builds histograms and scatter plot based on years, \ndepending on the distance from the sun and other measurement parameters.</p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter.__init__", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "manalyse.plot_funcs.Plotter.df", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.df", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter.label_counts_all", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.label_counts_all", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter.labels", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.labels", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter.counts_per_cluster", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.counts_per_cluster", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter.num_clusters", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.num_clusters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter.fields", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.fields", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter.xytitles", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.xytitles", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "manalyse.plot_funcs.Plotter.read_database", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.read_database", "kind": "function", "doc": "<p>Read a pandas DataFrame from a file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_to_read</strong> (str, optional):\nBase filename without extension.</li>\n<li><strong>kind</strong> ({'pickle', 'json'}):\nFormat of the file.</li>\n<li><strong>dtype</strong> (dict, optional):\nColumn types to enforce when reading JSON.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>pandas.DataFrame or None</strong>: The loaded DataFrame, or None if reading failed.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_to_read</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kind</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;pickle&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.create_name", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.create_name", "kind": "function", "doc": "<p>Constructs a filename by combining a base name with a suffix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>default_filename</strong> (str):\nBase filename.</li>\n<li><strong>file_to_write</strong> (str, optional):\nCustom filename provided by the user.</li>\n<li><strong>suffix</strong> (str, optional):\nSuffix to append to the filename.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Full filename with optional suffix.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">default_filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">file_to_write</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.hist_preparations", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.hist_preparations", "kind": "function", "doc": "<p>Prepare histogram settings: labels, colors, bin sizes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>cluster_labels</strong> (dict, optional):\nDictionary of labels to display on each subplot.</li>\n<li><strong>colors</strong> (list, optional):\nList of colors for clusters.</li>\n<li><strong>bins</strong> (list of int, optional):\nNumber of bins per field.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: (cluster_labels, colors, bins)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">cluster_labels</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bins</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.plot_one_hist", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.plot_one_hist", "kind": "function", "doc": "<p>Plot a single histogram for one field and cluster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ax</strong> (matplotlib.axes.Axes):\nAxis to plot on.</li>\n<li><strong>data</strong> (pandas.DataFrame):\nSubset of the data to plot.</li>\n<li><strong>xs</strong> (str):\nColumn name for x-axis.</li>\n<li><strong>color</strong> (str):\nColor of the histogram.</li>\n<li><strong>bin_num</strong> (int):\nNumber of histogram bins.</li>\n<li><strong>xtitle</strong> (str):\nX-axis title.</li>\n<li><strong>xrange</strong> (tuple or None):\nX-axis limits.</li>\n<li><strong>label</strong> (str):\nY-axis label.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">xs</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">color</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">bin_num</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">xtitle</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">xrange</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">label</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.plot_hists", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.plot_hists", "kind": "function", "doc": "<p>Plot histograms of selected fields for each cluster using a grid layout.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>gs</strong> (matplotlib.gridspec.GridSpec):\nGridSpec layout.</li>\n<li><strong>cluster_labels</strong> (dict, optional):\nText annotations per subplot.</li>\n<li><strong>colors</strong> (list of colors, optional):\nColors for each cluster.</li>\n<li><strong>bins</strong> (list of int, optional):\nNumber of bins for each field.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">gs</span>,</span><span class=\"param\">\t<span class=\"n\">cluster_labels</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bins</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.plot_preparations", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.plot_preparations", "kind": "function", "doc": "<p>Prepare color palettes and label strings for plotting by year.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>labels_to_plot</strong> (array-like, optional):\nLabels to include.</li>\n<li><strong>labels</strong> (list of str, optional):\nCustom label names.</li>\n<li><strong>axes_colors</strong> (list, optional):\nColors for each y-axis.</li>\n<li><strong>point_colors</strong> (list, optional):\nColors for scatter points.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: (axes_colors, point_colors, labels_to_plot, print_label)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">labels_to_plot</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">labels</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">axes_colors</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">point_colors</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.plot", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.plot", "kind": "function", "doc": "<p>Plot field values over time for each cluster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ax</strong> (matplotlib.axes.Axes):\nAxis to plot on.</li>\n<li><strong>field</strong> (str):\nField to plot.</li>\n<li><strong>labels_to_plot</strong> (list or array):\nCluster labels to include.</li>\n<li><strong>print_label</strong> (list of str):\nLabel names to use in legend.</li>\n<li><strong>point_colors</strong> (list of str):\nColors for each cluster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">labels_to_plot</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">print_label</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">point_colors</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.plot_twin_ax", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.plot_twin_ax", "kind": "function", "doc": "<p>Plot a field on a new twin y-axis.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ax_new</strong> (matplotlib.axes.Axes):\nTwin axis.</li>\n<li><strong>i</strong> (int):\nIndex of the field.</li>\n<li><strong>field</strong> (str):\nField to plot.</li>\n<li><strong>color</strong> (str):\nColor of the plot.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax_new</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">color</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.plot_dist_to_sun", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.plot_dist_to_sun", "kind": "function", "doc": "<p>Plot distance to sun and other metadata fields as time series\nusing shared x-axis and multiple y-axes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ax</strong> (matplotlib.axes.Axes):\nMain axis.</li>\n<li><strong>labels_to_plot</strong> (list, optional):\nCluster labels.</li>\n<li><strong>labels</strong> (list of str, optional):\nCustom label names.</li>\n<li><strong>axes_colors</strong> (list, optional):\nColors for y-axes.</li>\n<li><strong>point_colors</strong> (list, optional):\nColors for points.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">axes</span><span class=\"o\">.</span><span class=\"n\">_axes</span><span class=\"o\">.</span><span class=\"n\">Axes</span>,</span><span class=\"param\">\t<span class=\"n\">labels_to_plot</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">labels</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">axes_colors</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">point_colors</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "manalyse.plot_funcs.Plotter.save_fig", "modulename": "manalyse.plot_funcs", "qualname": "Plotter.save_fig", "kind": "function", "doc": "<p>Saves the clustering plot in PDF and PNG formats.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>filename</strong> (str):\nBase filename to use for saving.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();